% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_overall_benefit_performance.R
\name{compute_overall_benefit_performance}
\alias{compute_overall_benefit_performance}
\title{Estimate Observed vs Predicted Treatment Benefit Calibration}
\usage{
compute_overall_benefit_performance(
  data,
  drug_var,
  outcome_var,
  pred_cols = NULL,
  conc_tolerance = NULL,
  matching_var = NULL,
  match.exact = NULL,
  match.antiexact = NULL
)
}
\arguments{
\item{data}{A data frame containing individual-level data including treatment assignments, outcomes, and predicted treatment benefits.}

\item{drug_var}{Character. Column name indicating the treatment actually received by each patient.}

\item{outcome_var}{Character. Column name for the outcome variable to assess treatment effect.}

\item{pred_cols}{Character vector. Column names of predicted outcomes or risks for each treatment. These should share a common prefix (e.g., "pred_GLP1", "pred_SGLT2").}

\item{conc_tolerance}{Optional numeric scalar. If provided, patients are considered concordant if they received any treatment within this absolute difference of the best predicted outcome. If NULL (default), concordance requires receiving the top predicted treatment exactly.}

\item{matching_var}{Character vector. Names of covariates used for Mahalanobis distance matching between concordant and discordant patients.}

\item{match.exact}{Optional character vector. Variables for exact matching. The best predicted treatment is always included automatically.}

\item{match.antiexact}{Optional character vector. Variables for anti-exact matching (i.e., variables on which matches must differ). The actual treatment variable is always included automatically.}

\item{cal_groups}{Integer. Number of calibration groups to stratify patients based on predicted benefit (currently not directly used but reserved for future enhancements).}
}
\value{
A named list with two elements:

\describe{
\item{calibration_intercept}{A one-row data frame with the intercept of the linear regression model (\code{calibration_obs ~ calibration_pred}), representing the average deviation from perfect calibration when the predicted difference is zero. Includes:}
\describe{
\item{value}{Estimated intercept.}
\item{lci}{Lower 95\\% confidence interval for the intercept.}
\item{uci}{Upper 95\\% confidence interval for the intercept.}
}

\item{calibration_slope}{A one-row data frame with the slope of the regression model, representing how well predicted differences in treatment effect correspond to observed differences. Includes:}
\describe{
\item{value}{Estimated slope. A value near 1 indicates good calibration.}
\item{lci}{Lower 95\\% confidence interval for the slope.}
\item{uci}{Upper 95\\% confidence interval for the slope.}
}
}

Each estimate reflects model fit across matched patient pairs grouped by predicted benefit.
}
\description{
This function evaluates how well predicted treatment benefits align with observed outcome differences. It groups patients by predicted benefit and compares outcomes between patients who received treatments concordant or discordant with the predicted optimal treatment. Concordance can be defined strictly by the top predicted treatment or flexibly within a specified tolerance of the best predicted outcome.
}
\details{
To control for confounding, the function performs nearest-neighbor matching based on specified covariates before estimating observed treatment effect differences within matched pairs. The observed differences are then regressed against predicted differences to assess calibration of predicted treatment benefits.

This function uses nearest-neighbor matching (via the MatchIt package) on a set of covariates to create matched groups of concordant and discordant patients. Within each calibration group defined by predicted benefit, the observed difference in outcome is regressed on the predicted difference to assess calibration.
}
\examples{
\dontrun{
result <- compute_overall_benefit_performance(
  data = data_example,
  drug_var = "treatment",
  outcome_var = "outcome",
  pred_cols = c("pred_GLP1", "pred_SGLT2", "pred_DPP4"),
  conc_tolerance = 0.05,
  matching_var = c("age", "sex"),
  match.exact = NULL,
  match.antiexact = NULL
)
print(result)
}
}
